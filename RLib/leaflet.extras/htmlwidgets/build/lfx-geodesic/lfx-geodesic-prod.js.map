{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/Leaflet.Geodesic/Leaflet.Geodesic.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Number","toRadians","this","Math","PI","toDegrees","L","Geodesic","Polyline","extend","options","color","steps","dash","wrap","initialize","latlngs","_merge_options","max","min","parseFloat","datum","ellipsoid","a","b","f","_latlngs","_generate_Geodesic","setLatLngs","getStats","poly","points","obj","distance","polygons","length","_vincenty_inverse","geoJson","geojson","normalized","GeoJSON","asFeature","features","type","feature","geometry","coords","coordinates","push","coordsToLatLngs","console","log","createCircle","center","radius","step","polylineIndex","prev","lat","lng","brg","direct","_vincenty_direct","latLng","gp","abs","inverse","sec","_intersection","initialBearing","_geo","_geocnt","pointA","pointB","equals","dist_mult","direct_full","p1","σʹ","sinσ","cosσ","cos2σM","φ1","λ1","α1","sinα1","sin","cosα1","cos","tanU1","tan","cosU1","sqrt","sinU1","σ1","atan2","sinα","cosSqα","uSq","A","B","σ","iterations","λ2","x","φ2","C","revAz","finalBearing","p2","λʹ","sinλ","cosλ","tanU2","cosU2","sinU2","λ","sinSqσ","isNaN","fwdAz","toFixed","brng1","brng2","θ13","θ23","Δφ","Δλ","δ12","asin","θ1","acos","θ12","θ21","θ2","α2","α3","δ13","φ3","λ3","obj1","obj2","obj3","attrname","geodesic"],"mappings":"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","file":"lfx-geodesic-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\n\n// This file is part of Leaflet.Geodesic.\n// Copyright (C) 2017  Henry Thasler\n// based on code by Chris Veness Copyright (C) 2014 https://github.com/chrisveness/geodesy\n//\n// Leaflet.Geodesic is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Leaflet.Geodesic is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Leaflet.Geodesic.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/** Extend Number object with method to convert numeric degrees to radians */\nif (typeof Number.prototype.toRadians === \"undefined\") {\n  Number.prototype.toRadians = function() {\n    return this * Math.PI / 180;\n  };\n}\n\n/** Extend Number object with method to convert radians to numeric (signed) degrees */\nif (typeof Number.prototype.toDegrees === \"undefined\") {\n  Number.prototype.toDegrees = function() {\n    return this * 180 / Math.PI;\n  };\n}\n\nvar INTERSECT_LNG = 179.999; // Lng used for intersection and wrap around on map edges\n\nL.Geodesic = L.Polyline.extend({\n  options: {\n    color: \"blue\",\n    steps: 10,\n    dash: 1,\n    wrap: true\n  },\n\n  initialize: function(latlngs, options) {\n    this.options = this._merge_options(this.options, options);\n    this.options.dash = Math.max(1e-3, Math.min(1, parseFloat(this.options.dash) || 1));\n    this.datum = {};\n    this.datum.ellipsoid = {\n        a: 6378137,\n        b: 6356752.3142,\n        f: 1 / 298.257223563\n      }; // WGS-84\n    this._latlngs = this._generate_Geodesic(latlngs);\n    L.Polyline.prototype.initialize.call(this, this._latlngs, this.options);\n  },\n\n  setLatLngs: function(latlngs) {\n    this._latlngs = this._generate_Geodesic(latlngs);\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Calculates some statistic values of current geodesic multipolyline\n   * @returns (Object} Object with several properties (e.g. overall distance)\n   */\n  getStats: function() {\n    let obj = {\n        distance: 0,\n        points: 0,\n        polygons: this._latlngs.length\n      }, poly, points;\n\n    for (poly = 0; poly < this._latlngs.length; poly++) {\n      obj.points += this._latlngs[poly].length;\n      for (points = 0; points < (this._latlngs[poly].length - 1); points++) {\n        obj.distance += this._vincenty_inverse(this._latlngs[poly][points],\n          this._latlngs[poly][points + 1]).distance;\n      }\n    }\n    return obj;\n  },\n\n\n  /**\n   * Creates geodesic lines from geoJson. Replaces all current features of this instance.\n   * Supports LineString, MultiLineString and Polygon\n   * @param {Object} geojson - geosjon as object.\n   */\n  geoJson: function(geojson) {\n\n    let normalized = L.GeoJSON.asFeature(geojson);\n    let features = normalized.type === \"FeatureCollection\" ? normalized.features : [\n      normalized\n    ];\n    this._latlngs = [];\n    for (let feature of features) {\n      let geometry = feature.type === \"Feature\" ? feature.geometry :\n        feature,\n        coords = geometry.coordinates;\n\n      switch (geometry.type) {\n        case \"LineString\":\n          this._latlngs.push(this._generate_Geodesic([L.GeoJSON.coordsToLatLngs(\n            coords, 0)]));\n          break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n          this._latlngs.push(this._generate_Geodesic(L.GeoJSON.coordsToLatLngs(\n            coords, 1)));\n          break;\n        case \"Point\":\n        case \"MultiPoint\":\n          console.log(\"Dude, points can't be drawn as geodesic lines...\");\n          break;\n        default:\n          console.log(\"Drawing \" + geometry.type +\n            \" as a geodesic is not supported. Skipping...\");\n      }\n    }\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Creates a great circle. Replaces all current lines.\n   * @param {Object} center - geographic position\n   * @param {number} radius - radius of the circle in metres\n   */\n  createCircle: function(center, radius) {\n    let polylineIndex = 0;\n    let prev = {\n      lat: 0,\n      lng: 0,\n      brg: 0\n    };\n    let step;\n\n    this._latlngs = [];\n    this._latlngs[polylineIndex] = [];\n\n    let direct = this._vincenty_direct(L.latLng(center), 0, radius, this.options\n      .wrap);\n    prev = L.latLng(direct.lat, direct.lng);\n    this._latlngs[polylineIndex].push(prev);\n    for (step = 1; step <= this.options.steps;) {\n      direct = this._vincenty_direct(L.latLng(center), 360 / this.options\n        .steps * step, radius, this.options.wrap);\n      let gp = L.latLng(direct.lat, direct.lng);\n      if (Math.abs(gp.lng - prev.lng) > 180) {\n        let inverse = this._vincenty_inverse(prev, gp);\n        let sec = this._intersection(prev, inverse.initialBearing, {\n          lat: -89,\n          lng: ((gp.lng - prev.lng) > 0) ? -INTERSECT_LNG : INTERSECT_LNG\n        }, 0);\n        if (sec) {\n          this._latlngs[polylineIndex].push(L.latLng(sec.lat, sec.lng));\n          polylineIndex++;\n          this._latlngs[polylineIndex] = [];\n          prev = L.latLng(sec.lat, -sec.lng);\n          this._latlngs[polylineIndex].push(prev);\n        } else {\n          polylineIndex++;\n          this._latlngs[polylineIndex] = [];\n          this._latlngs[polylineIndex].push(gp);\n          prev = gp;\n          step++;\n        }\n      } else {\n        this._latlngs[polylineIndex].push(gp);\n        prev = gp;\n        step++;\n      }\n    }\n\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Creates a geodesic Polyline from given coordinates\n   * Note: dashed lines are under work\n   * @param {Object} latlngs - One or more polylines as an array. See Leaflet doc about Polyline\n   * @returns (Object} An array of arrays of geographical points.\n   */\n  _generate_Geodesic: function(latlngs) {\n    let _geo = [], _geocnt = 0;\n\n    for (let poly = 0; poly < latlngs.length; poly++) {\n      _geo[_geocnt] = [];\n      let prev = L.latLng(latlngs[poly][0]);\n      for (let points = 0; points < (latlngs[poly].length - 1); points++) {\n        // use prev, so that wrapping behaves correctly\n        let pointA = prev;\n        let pointB = L.latLng(latlngs[poly][points + 1]);\n        if (pointA.equals(pointB)) {\n          continue;\n        }\n        let inverse = this._vincenty_inverse(pointA, pointB);\n        _geo[_geocnt].push(prev);\n        for (let s = 1; s <= this.options.steps;) {\n          let distance = inverse.distance / this.options.steps;\n          // dashed lines don't go the full distance between the points\n          let dist_mult = s - 1 + this.options.dash;\n          let direct = this._vincenty_direct(pointA, inverse.initialBearing, distance*dist_mult, this.options.wrap);\n          let gp = L.latLng(direct.lat, direct.lng);\n          if (Math.abs(gp.lng - prev.lng) > 180) {\n            let sec = this._intersection(pointA, inverse.initialBearing, {\n              lat: -89,\n              lng: ((gp.lng - prev.lng) > 0) ? -INTERSECT_LNG : INTERSECT_LNG\n            }, 0);\n            if (sec) {\n              _geo[_geocnt].push(L.latLng(sec.lat, sec.lng));\n              _geocnt++;\n              _geo[_geocnt] = [];\n              prev = L.latLng(sec.lat, -sec.lng);\n              _geo[_geocnt].push(prev);\n            } else {\n              _geocnt++;\n              _geo[_geocnt] = [];\n              _geo[_geocnt].push(gp);\n              prev = gp;\n              s++;\n            }  \n          } else {\n            _geo[_geocnt].push(gp);\n            // Dashed lines start a new line\n            if (this.options.dash < 1){\n                _geocnt++;\n                // go full distance this time, to get starting point for next line\n                let direct_full = this._vincenty_direct(pointA, inverse.initialBearing, distance*s, this.options.wrap);\n                _geo[_geocnt] = [];\n                prev = L.latLng(direct_full.lat, direct_full.lng);\n                _geo[_geocnt].push(prev);\n            }\n            else prev = gp;\n            s++;\n          }\n        }\n      }\n      _geocnt++;\n    }\n    return _geo;\n  },\n\n  /**\n   * Vincenty direct calculation.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @private\n   * @param {number} initialBearing - Initial bearing in degrees from north.\n   * @param {number} distance - Distance along bearing in metres.\n   * @returns (Object} Object including point (destination point), finalBearing.\n   */\n\n  _vincenty_direct: function(p1, initialBearing, distance, wrap) {\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var α1 = initialBearing.toRadians();\n    var s = distance;\n\n    var a = this.datum.ellipsoid.a,\n      b = this.datum.ellipsoid.b,\n      f = this.datum.ellipsoid.f;\n\n    var sinα1 = Math.sin(α1);\n    var cosα1 = Math.cos(α1);\n\n    var tanU1 = (1 - f) * Math.tan(φ1),\n      cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)),\n      sinU1 = tanU1 * cosU1;\n    var σ1 = Math.atan2(tanU1, cosα1);\n    var sinα = cosU1 * sinα1;\n    var cosSqα = 1 - sinα * sinα;\n    var uSq = cosSqα * (a * a - b * b) / (b * b);\n    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 *\n      uSq)));\n    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n\n    var σ = s / (b * A),\n      σʹ, iterations = 0;\n    var sinσ, cosσ;\n    var cos2σM;\n    do {\n      cos2σM = Math.cos(2 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM *\n          cos2σM) -\n        B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM *\n          cos2σM)));\n      σʹ = σ;\n      σ = s / (b * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations);\n\n    var x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    var φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - f) *\n      Math.sqrt(sinα * sinα + x * x));\n    var λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\n    var L = λ - (1 - C) * f * sinα *\n      (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n\n    var λ2;\n    if (wrap) {\n      λ2 = (λ1 + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180...+180\n    } else {\n      λ2 = (λ1 + L); // do not normalize\n    }\n\n    var revAz = Math.atan2(sinα, -x);\n\n    return {\n      lat: φ2.toDegrees(),\n      lng: λ2.toDegrees(),\n      finalBearing: revAz.toDegrees()\n    };\n  },\n\n  /**\n   * Vincenty inverse calculation.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @private\n   * @param {LatLng} p1 - Latitude/longitude of start point.\n   * @param {LatLng} p2 - Latitude/longitude of destination point.\n   * @returns {Object} Object including distance, initialBearing, finalBearing.\n   * @throws {Error} If formula failed to converge.\n   */\n  _vincenty_inverse: function(p1, p2) {\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var φ2 = p2.lat.toRadians(),\n      λ2 = p2.lng.toRadians();\n\n    var a = this.datum.ellipsoid.a,\n      b = this.datum.ellipsoid.b,\n      f = this.datum.ellipsoid.f;\n\n    var L = λ2 - λ1;\n    var tanU1 = (1 - f) * Math.tan(φ1),\n      cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)),\n      sinU1 = tanU1 * cosU1;\n    var tanU2 = (1 - f) * Math.tan(φ2),\n      cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)),\n      sinU2 = tanU2 * cosU2;\n\n    var λ = L,\n      λʹ, iterations = 0;\n    var cosSqα, sinσ, cos2σM, cosσ, σ, sinλ, cosλ;\n    do {\n      sinλ = Math.sin(λ);\n      cosλ = Math.cos(λ);\n      var sinSqσ = (cosU2 * sinλ) * (cosU2 * sinλ) + (cosU1 * sinU2 -\n        sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\n      sinσ = Math.sqrt(sinSqσ);\n      if (sinσ == 0) return 0; // co-incident points\n      cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;\n      σ = Math.atan2(sinσ, cosσ);\n      var sinα = cosU1 * cosU2 * sinλ / sinσ;\n      cosSqα = 1 - sinα * sinα;\n      cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα;\n      if (isNaN(cos2σM)) cos2σM = 0; // equatorial line: cosSqα=0 (§6)\n      var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\n      λʹ = λ;\n      λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-\n        1 + 2 * cos2σM * cos2σM)));\n    } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 100);\n    if (iterations >= 100) {\n      console.log(\"Formula failed to converge. Altering target position.\");\n      return this._vincenty_inverse(p1, {\n          lat: p2.lat,\n          lng: p2.lng - 0.01\n        });\n        //  throw new Error('Formula failed to converge');\n    }\n\n    var uSq = cosSqα * (a * a - b * b) / (b * b);\n    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 *\n      uSq)));\n    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n    var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM *\n        cos2σM) -\n      B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM *\n        cos2σM)));\n\n    var s = b * A * (σ - Δσ);\n\n    var fwdAz = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 *\n      cosλ);\n    var revAz = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 *\n      cosλ);\n\n    s = Number(s.toFixed(3)); // round to 1mm precision\n    return {\n      distance: s,\n      initialBearing: fwdAz.toDegrees(),\n      finalBearing: revAz.toDegrees()\n    };\n  },\n\n\n  /**\n   * Returns the point of intersection of two paths defined by point and bearing.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @param {LatLon} p1 - First point.\n   * @param {number} brng1 - Initial bearing from first point.\n   * @param {LatLon} p2 - Second point.\n   * @param {number} brng2 - Initial bearing from second point.\n   * @returns {Object} containing lat/lng information of intersection.\n   *\n   * @example\n   * var p1 = LatLon(51.8853, 0.2545), brng1 = 108.55;\n   * var p2 = LatLon(49.0034, 2.5735), brng2 = 32.44;\n   * var pInt = LatLon.intersection(p1, brng1, p2, brng2); // pInt.toString(): 50.9078°N, 4.5084°E\n   */\n  _intersection: function(p1, brng1, p2, brng2) {\n    // see http://williams.best.vwh.net/avform.htm#Intersection\n\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var φ2 = p2.lat.toRadians(),\n      λ2 = p2.lng.toRadians();\n    var θ13 = Number(brng1).toRadians(),\n      θ23 = Number(brng2).toRadians();\n    var Δφ = φ2 - φ1,\n      Δλ = λ2 - λ1;\n\n    var δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ /\n        2)));\n    if (δ12 == 0) return null;\n\n    // initial/final bearings between points\n    var θ1 = Math.acos((Math.sin(φ2) - Math.sin(φ1) * Math.cos(δ12)) /\n      (Math.sin(δ12) * Math.cos(φ1)));\n    if (isNaN(θ1)) θ1 = 0; // protect against rounding\n    var θ2 = Math.acos((Math.sin(φ1) - Math.sin(φ2) * Math.cos(δ12)) /\n      (Math.sin(δ12) * Math.cos(φ2)));\n    var θ12, θ21;\n    if (Math.sin(λ2 - λ1) > 0) {\n      θ12 = θ1;\n      θ21 = 2 * Math.PI - θ2;\n    } else {\n      θ12 = 2 * Math.PI - θ1;\n      θ21 = θ2;\n    }\n\n    var α1 = (θ13 - θ12 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 2-1-3\n    var α2 = (θ21 - θ23 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 1-2-3\n\n    if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections\n    if (Math.sin(α1) * Math.sin(α2) < 0) return null; // ambiguous intersection\n\n    //α1 = Math.abs(α1);\n    //α2 = Math.abs(α2);\n    // ... Ed Williams takes abs of α1/α2, but seems to break calculation?\n\n    var α3 = Math.acos(-Math.cos(α1) * Math.cos(α2) +\n      Math.sin(α1) * Math.sin(α2) * Math.cos(δ12));\n    var δ13 = Math.atan2(Math.sin(δ12) * Math.sin(α1) * Math.sin(α2),\n      Math.cos(α2) + Math.cos(α1) * Math.cos(α3));\n    var φ3 = Math.asin(Math.sin(φ1) * Math.cos(δ13) +\n      Math.cos(φ1) * Math.sin(δ13) * Math.cos(θ13));\n    var Δλ13 = Math.atan2(Math.sin(θ13) * Math.sin(δ13) * Math.cos(φ1),\n      Math.cos(δ13) - Math.sin(φ1) * Math.sin(φ3));\n    var λ3 = λ1 + Δλ13;\n    λ3 = (λ3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180º\n\n    return {\n      lat: φ3.toDegrees(),\n      lng: λ3.toDegrees()\n    };\n  },\n\n  /**\n   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\n   * @param obj1\n   * @param obj2\n   * @returns obj3 a new object based on obj1 and obj2\n   */\n  _merge_options: function(obj1, obj2) {\n    let obj3 = {};\n    for (let attrname in obj1) {\n      obj3[attrname] = obj1[attrname];\n    }\n    for (let attrname in obj2) {\n      obj3[attrname] = obj2[attrname];\n    }\n    return obj3;\n  }\n});\n\nL.geodesic = function(latlngs, options) {\n  return new L.Geodesic(latlngs, options);\n};\n"],"sourceRoot":""}